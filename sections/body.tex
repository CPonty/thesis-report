\mainmatter

% =====================================================================

\chapter{Introduction}

A block diagram is a model of a system in which components or functions are represented by blocks, and relationships or connections between them by connecting lines. Block diagram models of engineering systems are heavily used by designers and educators in many fields, including hardware design, electronics design, software engineering, control systems and others.
\\

Sketching block diagrams (or block diagram equivalent designs) on a collaborative surface (such as a whiteboard) is a common part of the design process for engineering students, educators and professionals. Often the system being designed is subsequently analysed and simulated using a computer aided tool, requiring the sketched design to be manually reconstructed on a computer. It should be possible to reduce or eliminate this delay between sketch and simulation and thus increase productivity for system designers using an automated, computer aided process.
\\

Today there are plenty of available systems capable of handwriting recognition for various engineering designs. However, these are generally specialised for taking input from a stylus or touchscreen, and/or recognition of symbols and designs for a specific engineering domain.
\\

\textit{BlocSim}\footnote{BlocSim - http://www.github.com/CPonty/BlocSim} is a proof-of-concept for a sketch-to-simulation solution capable of servicing a broad range of engineering domains. Its role is to visually capture a sketch of a block-diagram-like model from a whiteboard, and update external simulation tools with an adapted model in real-time. For the sake of simplicity, capturing textual annotations adjacent to blocks is outside its scope.
\\

An open-source prototype of BlocSim shall be built which achieves this functionality for simple whiteboard sketches. BlocSim will be built with extensibility in mind, as expanding its ability to interface with third-party software will require updates over time.


\begin{comment}

\end{comment}

% =====================================================================

\chapter{Background}
\label{ch:back}

\section{Block Diagrams in Engineering}

%\subsection{Block Diagram Equivalent Drawings}

Across various engineering domains, block diagram and block-diagram-like models are capable of describing a variety of systems in sufficient detail to run a simulation directly from the diagram. In some cases, the block diagram model is almost equivalent to a schematic diagram (see digital logic gates). In others, information required is added as annotations to the component of the diagram (such as component values in electrical schematics). As such, a control system block diagram could be adapted for a simulator and executed immediately; an electrical circuit schematic treated as a block diagram would have key information missing, although delivering the circuit layout to simulation instantly is still a useful and desirable function. Similar comparisons can be made in many other domains where blocks are substituted for symbols. In short, basic schematic and other technical drawings can often be modelled as a generic block diagram, provided the components of the schematic can be recognized. Thinking of block diagrams in this broader sense will broaden the usefulness of BlocSim.
\\

%Recognition of this broad set of 'block diagram' components presents a challenge.

Consider textual annotations, such as that of a function block diagram or AC circuit, to be outside of the scope of BlocSim.

\begin{figure}[ht!]
\includegraphics[width=70mm]{images/blockDiagram.png}
\hspace{0.5 cm}
\includegraphics[width=50mm]{images/circuitDiagram2.png} \\
\includegraphics[width=50mm]{images/controlSystem.png} 
\hspace{0.5 cm}
\includegraphics[width=50mm]{images/fbd.jpg} 
\centering
\caption{Block diagram (top left) \cite{wiringDiagrams}, circuit diagram (top right) \cite{engineeronadisk}, control system block diagram (bottom left) \cite{engineeronadisk}, function block diagram (bottom right) \cite{wikicommonsFbd}}
\label{im:blockExample}
\end{figure}

%\clearpage
\newpage

\subsection{Simulation}

\subsubsection{Simulink}

Mathworks' \textit{Simulink toolbox} \cite{simulink} is a powerful tool for block diagram system simulation. It provides a block diagram environment for simulation and design of system models across a variety of domains. It includes a graphical editor, customisable library of blocks, solver tools for modelling and simulation of systems, and the ability to incorporate Matlab algorithms in the model. Simulink is an ideal candidate for integration with BlocSim.

\begin{figure}[ht!]
\includegraphics[width=75mm]{images/simulink.png} 
\centering
\caption{Simulink block diagram model}
\label{im:simulink}
\end{figure}

\subsubsection{LTSpice}

LTSpice \cite{ltspice}, a SPICE circuit schematic capture and simulation tool built by Linear Systems, is a typical example of a simulation tool which could take input from a block diagram model. Looking at the simple circuit example in Figure \ref{im:ltspice}, we can see that the schematic consists of components, lines and textual annotations on components. The SPICE netlist\footnote{Netlist - In the context of electronics design, a netlist conveys information about the instances (parts) used, how their pins/ports are connected, and some other attributes.} file representing the schematic is a straightforward sequence of human readable components, wire routes and component properties. Aside from component properties, a general purpose block diagram model including connector geometry contains sufficient information to be translated into an LTSpice circuit schematic, with block component type IDs map to circuit component types.

Similar arguments can be made for other tools and other engineering domains.

%\footnote{Netlist - In the context of electronics design, a netlist conveys information about the instances (parts) used, how their pins/ports are connected, and some other attributes.}

%\subsection{LTSpice}
%LTSpice, and spice 
%\cite{ltspice}

\begin{figure}[ht!]
\centering
\includegraphics[width=50mm]{images/ltspice1.png}
\includegraphics[width=50mm]{images/ltspice2.png}
\caption{Simple LTSpice circuit with corresponding netlist file \cite{ltspice}}
\label{im:ltspice}
\end{figure}

\clearpage

\section{Block Diagram Sketch Capture}

Recognition of the broad set of 'block diagram' components BlocSim could potentially need to interpret presents a challenge. In some domains, these blocks are simply boxes containing text. Optical Character Recognition (\gls{ocr}) is a well-established field in computer vision, and this does not present a challenge on its own. However, in some cases (such as control system block diagrams), the blocks contain mathematical expressions, presenting a problematically large set of sometimes ambiguous and complex symbols to recognise, especially when drawn by hand, on a whiteboard, in a compressed space. In other cases, such as electrical circuits, the block components are represented by symbols, and the containing border is missing. Again, there is a large symbol set, potentially multiple symbol sets given the range of engineering domains BlocSim may eventually support, and hand-drawn whiteboard sketches of symbols are imprecise at best. Implementing recognition algorithms for this multitude of block diagram types and domains would be extremely challenging.
\\

%\subsection{Engineering Sketch Recognition \& Simulation}
%\cite{sketchInterpSoftware}

\subsection{Hand-drawn Sketch Recognition}

Let us step back to consider a best-case scenario, and just one engineering domain. 

Paper sketches  of circuits are a simpler case to consider than whiteboards, as pens are more precise than whiteboard markers. It is worth noting how successful existing attempts to recognise and interpret electrical sketches on paper have been.
B. Edwards of QUT, Australia has achieved “node recognition accuracy of 82\% and a component recognition accuracy of 86\%” with a hand-drawn circuit diagram analyser which takes input from a scanner \cite{handDrawnCircuits}.

The vast majority of available literature regarding technical sketches on \textit{interactive} surfaces focuses on a surface sized for an individual, rather than a large collaborative surface such as a whiteboard. Users might input sketches through a light pen, stylus and touch-sensitive screen, or other methods \cite{sketchInterpSoftware}, and the software responds as they draw. 

Quickdiagram is a well-developed example of this. It is capable of recognising partially-drawn symbols and finishing (“beautifying”) them for the user as they draw with “robust and accurate” results, and either running nodal analysis (for resistive circuits) or delegating simulation to PSpice (for more complex circuits) \cite{quickDiagram}.

\begin{figure}[ht!]
\centering
\includegraphics[width=75mm]{images/sketchInterpSoftware.jpg}
\caption{Recognition of stylus-drawn electrical circuit components \cite{sketchInterpSoftware}}
\label{im:sketchInterpSoftware}
\end{figure}

\clearpage

%\cite{quickDiagram}
%\cite{quickDiagramDemo}

%\subsection{Interactive Whiteboards}
\subsection{Interactive Surfaces}

It should be noted that interactive surfaces, such as electronic whiteboards and large touchscreen panels exist. Interactive whiteboards are large, touch sensitive panels paired with a digital projector and computer, displaying information and providing control through direct touch or a special pen \cite{interactiveWhiteboards}. These may be an ideal surface for the purposes of BlocSim. They can be utilised in a similar fashion to standard whiteboards, yet are capable of loading and saving their state and interacting directly with a computer. Touchscreens offer similar capability to an interactive whiteboard, though the size/surface area is inherently limited.
\\

Despite these convenient features, a large, interactive sketching surface will not be used for the BlocSim prototype, as a whiteboard-sized system is prohibitively expensive. For example, in November 2013, Panasonic’s mid-range electronic whiteboards were retailing for approximately \$2,500 AUD \cite{panasonic}. Touchscreens large enough to replace the role of whiteboards are similarly expensive, with a 47” LG screen retailing for approximately \$3,000 AUD \cite{ledLcd}.

%\cite{interactiveWhiteboards}
%\cite{interactiveWhiteboards2}
%\cite{panasonic}
%\cite{ledLcd}

\subsection{Block Component Identification}

Given the material covered so far, it is apparent that in order to make BlocSim viable an alternate approach to block recognition will have to be taken. Instead of trying to recognise hand-drawn blocks on a whiteboard, an alternate approach would be to print a set of blocks onto magnetic cards for each relevant domain, and place image features, or \textit{fiducials}, onto the card to aid in its detection and identification.
\\

%introduce problem fiduciary markers
%markers
	%artag
%ocr
	%don't want to use OCR for many cases - math symbols, domain specific symbols
%barcodes (1D)
%QR codes (2D)
%\cite{fiducial}
%\cite{fiducialAR}
%\cite{colorFiducial}

\subsubsection{Fiduciary Markers}

Object recognition, or detection/identification of features in an image, is one of the major problems to be solved when performing computer vision tasks. Fiduciary markers are symbols know to the \gls{cv} algorithm, designed to be located and identified automatically in an image \cite{artag}. For BlocSim's purposes, detecting fiducials would be more reliable than recognition of abritrary sketched shapes.
\\

ARToolKit2 is a widely used Augmented Reality (\gls{ar}) system considered “state-of-the-art” to researchers and developers \cite{artoolkit}. Its capabilities include recognition of custom fiducials. ARToolKit2 applies edge detection, contouring and thresholding to analyse objects in the image. In the absence of uncontrolled lighting and marker occlusion, it is capable of consistent, near-100\% detection rates for symbols less than 100 pixels wide \cite{bestFiducial}. Users can create their own markers using arbirary symbols and train a classifier to facilitate their recognition. If BlocSim were to use a system such as this, blocks represented as symbols would treat the entire block as a fiducial, and text blocks would perform OCR.
\\

\begin{figure}[ht!]
\centering
\includegraphics[width=50mm]{images/artoolkit1.png}
\includegraphics[width=50mm]{images/artoolkit2.jpg}
\caption{Custom fiduciary markers for ARToolKit \cite{fiducialPic}}
\label{im:fiducialPic}
\end{figure}

\clearpage

Instead of using the block as a fiducial itself, it is possible to place smaller fiducials within the block. Printed circuit boards, for example, utilise fiduciary marks as pointers for machinery during the production process (see Figure \ref{im:fiducialPic} below). Simple fiduciary markers can encode information based on their position, separation distances (as used in PCBs) or their colour \cite{colorFiducial}.

\begin{figure}[ht!]
\centering
\includegraphics[width=50mm]{images/fiducialPic.jpg}
\caption{Example of fiducials present on a \gls{pcb} \cite{fiducialPic}}
\label{im:fiducialPic}
\end{figure}

\subsubsection{Barcodes}

Another potential method of encoding block identity is with a barcode. Barcodes are information dense and space efficient. A one-dimensional barcode could be run as a strip inside a block in a fixed position, or a 2D barcode (such as QR Code) placed in a corner. Traditional barcodes are not a desirable solution for BlocSim, as their rectangular shape would take up space inside the block which may be needed in some cases. For example, a block component might consist of a symbol with connector lines joining to all four sides of the block.


%\cite{bestFiducial}
%\cite{fiducialAR}
% G. Schall et al
%\cite{colorFiducial}
% H. Bagherinia et al

%------------------------------
%\cite{artag}
%\cite{bestFiducial}
%\cite{artoolkit}
%\cite{ltspice}

%\cite{fiducialAR}
% G. Schall et al
%\cite{colorFiducial}
% H. Bagherinia et al

%\begin{figure}[ht!]
%\centering
%\includegraphics[width=50mm]{images/fiducialPic.jpg}
%\caption{Example of fiducials present on a \gls{pcb} \cite{fiducialPic}}
%\label{im:fiducialPic}
%\end{figure}


% =====================================================================

\subsubsection{Frame Markers}
\label{ch:back:borders}

As an alternative to symbol, text or traditional barcode recognition, a special type of fiducial can be constructed called a frame marker. The concept is that the unique ID of the marker is encoded in a pattern along its border, rather than in the central contents area. This means that the majority of the marker surface is not required during image recongnition, allowing a user to place any image, text, symbolic or other content here as they see fit without affecting the recognition of the marker.

An extremely simple version of this concept could involve placing a small dot in the corner of the marker which corresponds to its unique ID. This gives 4 possible marker types. A more comprehensive alternative could encode the unique ID in a continuous, barcode-like pattern along the inner border of the marker. This could allow for a range of hundreds of unique IDs, only limited by the resolution of the marker in the image.

Vuforia\footnote{Vuforia - \url{https://www.vuforia.com}}, a computer vision platform for augmented reality (\gls{ar}) on mobile devices, implements frame marker recognition. For the marker type in Figure \ref{im:frameMarker}, a range of 512 unique IDs are available, with relatively low processing power required for recognition \cite{vuforia}. However, verbatim use of this implementation does not suit BlocSim - Vuforia's markers require a clearance area around the frame border free of graphical features, while in a block diagram sketch the connector lines will violate this space.

If BlocSim were to make use of it, symbolic blocks and text blocks with fixed content would be encoded entirely using the frame; text blocks with dynamic content would be identified by their frame and parsed using OCR.
%, allowing a very large range of types and increasing reliability by removing the need for colour detection.

\begin{figure}[ht!]
\centering
\includegraphics[width=50mm]{images/frameMarker.png}
\caption{Vuforia Frame Marker fiducial example \cite{vuforia}}
\label{im:frameMarker}
\end{figure}

\clearpage

%\cite{vuforia}

% =====================================================================

\section{Open Source Software}

A key benefit of writing free and open source software (\gls{foss}) comes from creating opportunity for others to contribute to a project. However, this requires the developers to create an environment suitable for collaboration, which involves more than simply writing nicely formatted \& documented code.
\\

\subsection{Contributors}

Contributions to an active open-source project come from many contributor roles. Aside from \textit{developers} writing and documenting code, there should be \textit{testers} actively using and testing the project, people providing \textit{user support} by answering questions (e.g. on a forum), \textit{bug reporters} and regular \textit{users}. Any one contributor can fill several roles. A final and important role are the project's \textit{observers}, who may be considering becoming contributors.

Clearly all of these roles are important ones. Therefore, it is beneficial to setup infrastructure to support all of them. This can include, but is not limited to:
\begin{description}
	\item[Ease of Access] - providing a convenient means for users to acquire \& run the software
	\item[Project Monitoring] - keeping all roles informed with the status of the project, such as the roles of developers, changesets, project direction
	\item[User Support] - providing a means for users to learn about the project, seek help with issues and contact developers
	\item[Issue Tracking] - providing a means for users and developers to create and monitor bug reports or suggestions for new features. This functionality is at the core of open source development
	\item[Centralised source control] - ensure developers have a central 'source of truth', with the ability to effectively manage distributed development and merge work
\end{description}

Taking steps to support contributors is a key to success for all open source projects. \cite{openSource2}. 

\textit{GitHub}\footnote{GitHub - \url{https://www.github.com/}} is a highly valuable and widely used online space for open source software projects. It provides a \textit{Git}\footnote{Git - \url{http://www.git-scm.com/}} version control system, facilitating branches of development and the ability to rollback/merge changes, a wiki page for documentation, release management and an issue tracker.

\vspace{0.5 cm}

\subsection{Software Evaluation \& Selection}

Selection of existing software, libraries and tools for use in a project must be carefully considered. Often there exists a wide range of possible off-the-shelf components which can fill a given requirement, and each must be evaluated on its merits to the project. Evaluation can involve, but is not limited to, researching views and opinions from the open source community and reading source code and documentation. Selection criteria are broad, and may include source code quality, documentation quality and completeness, maturity, stability, cross-platform support, ease of use \& maintenance, and importantly the permissiveness of its licensing. \cite{openSource}
\\

Given that BlocSim's key functionality requires converting block models to be compatible with a variety of third party software, it will require maintenance and ongoing work over time. A FOSS model will serve the project well.

% =====================================================================


\section{Computer Vision Software}
\label{sec:cv}

As BlocSim's core functionality involves interpreting hand-drawn sketches, it will require the ability to perform image processing on a captured sketch.

\subsection{Computer Vision Frameworks}

A large number of free, off-the-shelf image processing and computer vision libraries are available to this project. In order to minimise time required to implement the BlocSim prototype, evaulation of options focuses on frameworks I have previous experience with. Two such frameworks were evaluated for this project: Mathworks' \textit{Computer Vision System toolbox} \cite{matlab} and the OpenCV Foundation's \textit{Open Source Computer Vision Library} (OpenCV) \cite{opencv}.
\\

In terms of performance, OpenCV has a strong advantage over most freely available frameworks.
Its stated purpose is to "provide a common infrastructure for computer vision applications and to accelerate the use of machine perception" \cite{opencv}. OpenCV is a proven product, with an active community of over 47,000 users and extensive use among well-established software companies. OpenCV began its life as a project in Intel's labs, resulting in Intel's Integrated Performance Primitives (IPP), which include assembly routines for computer vision optimised by hand \cite{opencvBook}. While OpenCV APIs are available for several languages including Java and python, the core functionality is written in compiled, optimised C++. For these reasons, OpenCV generally outperforms other freely available open source libraries \cite{opencvBench}.
\\

Working in Matlab offers different advantages. Matlab's Computer Vision System toolbox actually integrates the OpenCV library into Matlab, allowing access to Matlab's convenient visualisation and data processing capabilities, higher levels of abstraction and an extended image processing library \cite{matlabCV}. However, working with Matlab would present several problems:

\begin{itemize}
\item Matlab is commercial software with considerable purchase cost, which would erode the project's open-source value
\item As a large software package running in a Java virtual machine, Matlab's performance does not match that of utilising OpenCV directly
\item Writing features of BlocSim outside of computer vision will be more convenient in a standalone program than executing in a data analysis tool,
\end{itemize}

\begin{figure}[ht!]
\centering
\includegraphics[width=25mm]{images/OpenCVlogo.png}
\caption{The OpenCV Logo \cite{opencv}}
\label{im:cvlogo}
\end{figure}

%\subsection{Techniques}


%select OpenCV; discuss useful features it has with footnotes
% colour thresholding
% contour heirarchy
% adaptive thresholding

%\cite{matlab}
%\cite{opencvBench}
%%\cite{opencvBook}



% =====================================================================

\chapter{BlocSim Specification}
\label{ch:spec}

The BlocSim prototype's role is to capture a sketch of a block-diagram-like model from a whiteboard using a webcam, and update external simulation tools with an adapted model in real-time. 

%\newpage
\section{Solution Concept}

In considering the direction to take with the BlocSim prototype, the following idea has been given precedence: 
\\

\setlength{\leftskip}{1cm}

\noindent The created prototype should above all be functional, configurable, extensible, flexible, user friendly and have transparent functionality, as the BlocSim project will require further work after the prototype's completion
\\

\setlength{\leftskip}{0cm}

%\subsection{Feature Requirements}

\noindent Keeping this statement in mind, the computer vision methodology is to be implemented in as straightforward and reliable fashion as possible.

A list of features the prototype should include, expressed in an 'Agile Story' format:

\begin{itemize}
\item The user should have the ability to view the computer vision process in real time, both as a demonstration and for debugging purposes
\item The user should have the ability to configure constants/parameters for image processing in real time
\item The user should have the ability to control and configure BlocSim remotely
\item The user should have the ability to write their own software which controls BlocSim
\item BlocSim should publish the block diagram model it recognizes to a location accessible to other software
\item The user should have the ability to write their own 'Adapter' software, to receive BlocSim's model of the block diagram being viewed, reinterpret it into a domain-specific model, and forward it to an external simulation tool
\item The prototype should include an example of the above for logic gate simulation

These requirements give rise to the high-level system design shown in Figure \ref{im:BlocsimBD1}.
\end{itemize}

%The BlocSim Prototype
%TODO


\begin{figure}[ht!]
\centering
\includegraphics[width=150mm]{images/BlocsimBD1.jpg}
\caption{BlocSim System Design \cite{blocsimPoster}}
\label{im:BlocsimBD1}
\end{figure}

%\newpage
\clearpage





\section{Block Diagram Capture}

\subsection{Fiducial Design}

The design of the block fiducial markers for the BlocSim prototype borrows from the simplest available concepts analysed in Chapter \ref{ch:back}. The blocks involved in the block diagram sketch are to be printed preassembled on pieces of magnetic card. The magnetic cards can be placed on the whiteboard to construct the block diagram. The method of encoding the block type is the simplest possible: place a coloured dot in one of the four corners of the block; it's position yields the block type. Instead of leaving a margin of empty space around the block marker (the approach of ARTag and Vuforia, Section \ref{ch:back:borders}), make the block marker border a colour reserved for block borders within the image, allowing drawn connector lines to contact it.

Image features are colour-coded as per Table \ref{tab:color}; block types identified as per Table \ref{tab:blockid}. Black is chosen for hand-drawn lines to maximise reliability. Red and Green are a suitable pair of colours to utilise as they are easily separated in common colour spaces: in the Red, Green, Blue (\gls{rgb}) colour space, they exist on separate channels; in the Hue, Saturation, Value (\gls{hsv}) colour space, they are separated by 120 degrees on the hue wheel.

\begin{table}[ht!]
	\center
	\begin{tabular}{r l} %$
		\hline
		\rowstyle{\bfseries}
		Image Feature & Colour \\
		\hline
		Hand-Drawn Connector Lines & \textbf{Black} \\
		Block Marker Border & \textbf{Red} \\
		Block Marker Fiduciary Dot & \textbf{Green} \\
		\hline
	\end{tabular}
	\caption{Colour allocation for the BlocSim whiteboard block diagram}
	\label{tab:color}
\end{table} 
%\vspace{0.5 cm}
\begin{table}[ht!]
	\center
	\begin{tabular}{r l} %$
		\hline
		\rowstyle{\bfseries}
		Fiduciary Dot Location & Block Type ID \\
		\hline
		Top-Left & 0 / A \\
		Top-Right & 1 / B \\
		Bottom-Right & 2 / C \\
		Bottom-Left & 3 / D \\
		\hline
	\end{tabular}
	\caption{Block Type decoding in the BlocSim whiteboard block diagram}
	\label{tab:blockid}
\end{table} 
\vspace{0.5 cm}

This approach was chosen primarily for its simplicity in the prototype. The block designs are sufficiently simple to be drawn by hand using regular whiteboard markers.
\\

The primary drawback is that the blocks cannot be rotated past +/- 45 degrees - the computer vision algorithm will not be aware that the block is on its side, as it has no orientation information.

%TODO table mapping corners to A/0
%TODO table mapping corners to A/0

%TODO


\begin{figure}[ht!]
\centering
\includegraphics[width=100mm]{images/BlocsimBloc1.jpg}
\includegraphics[width=100mm]{images/BlocsimBloc2.jpg}
\includegraphics[width=100mm]{images/BlocsimBloc3.jpg}
\caption{BlocSim Block Diagram formats: Sketch (top), Model (middle), Digital Logic (lower).}
\label{im:BlocsimBloc}
\end{figure}

%\begin{figure}[ht!]
%\centering
%\includegraphics[width=100mm]{images/BlocsimBloc2.jpg}
%\caption{BlocSim Block Diagram format (model)}
%\label{im:BlocsimBD2}
%\end{figure}

%\begin{figure}[ht!]
%\centering
%\includegraphics[width=100mm]{images/BlocsimBloc3.jpg}
%\caption{BlocSim Block Diagram format (block types A,B,C,D mapped to Digital Logic gates)}
%\label{im:BlocsimBD3}
%\end{figure}

\clearpage


%TODO


%\newpage

\section{Technology Selection}
\label{sec:techSelection}

\begin{table}[ht!]
	\center
	\begin{tabular}{$r^l} %$
		\hline
		\rowstyle{\bfseries}
		Component & Selected Technology \\
		\hline \\
		Primary Programming Language & \textbf{Python} \footnotemark[1] \\
		Computer Vision Package & \textbf{OpenCV} \footnotemark[2] \\
		Human Interface & Web control panel \\
		Web Framework & \textbf{Tornado} \footnotemark[3] \\
		Communication/Storage Format & \textbf{\gls{json}} \footnotemark[4] \\
		Remote Access & \textbf{JSON-RPC} \footnotemark[5] protocol via \textbf{TornadoRPC} \footnotemark[6] \\
		Client-Server Communication & \textbf{Websockets} \footnotemark[7], using \textbf{SockJS} \footnotemark[8] \& \textbf{SockJS-Tornado} \footnotemark[9] \\
		Block Diagram Publishing & \textbf{Mosquitto} \footnotemark[10] Publish/Subscribe Broker \\
		\\
		\hline
	\end{tabular}
	\caption{Selection of technologies for the BlocSim prototype}
	\label{tab:techSelect}
\end{table} 



In order to fulfil the feature requirements laid out above, a series of choices must be made regarding which technologies, libraries and tools to use in which roles.

%\cite{facebookTornado}
%\cite{socketioBugs}
%\footnotemark[11]
%\footnotemark[12]
%\footnotemark[13]
%\footnotemark[14]
\footnotetext[1]{Python - \url{https://www.python.org/}}
\footnotetext[2]{OpenCV - \url{http://opencv.org/}} 
\footnotetext[3]{Tornado - \url{http://www.tornadoweb.org/en/stable/}}
\footnotetext[4]{JSON - \url{http://json.org/}}
\footnotetext[5]{JSON-RPC - \url{http://json-rpc.org/wiki/specification}}
\footnotetext[6]{TornadoRPC - \url{https://github.com/joshmarshall/tornadorpc}}
\footnotetext[7]{Websockets - \url{http://www.websocket.org/}}
\footnotetext[8]{SockJS - \url{https://github.com/sockjs/sockjs-client}}
\footnotetext[9]{SockJS-Tornado - \url{https://github.com/mrjoes/sockjs-tornado}}
\footnotetext[10]{Mosquitto - \url{http://mosquitto.org/}}
\footnotetext[11]{Flask - \url{http://flask.pocoo.org/}}
\footnotetext[12]{Socket.io - \url{http://socket.io/}}
\footnotetext[13]{Redis - \url{http://redis.io/}}
%\footnotetext[14]{Meteor - \url{https://www.meteor.com/}}

\newpage

\begin{description}
	\item[Python] was selected as the primary programming language. It is well suited to the role of acting as 'glue' between a multitude of libraries in prototyping projects. I am also highly familiar with python, which will expedite development.
	\item[OpenCV] was selected as the computer vision library of choice, as per analysis in Section \ref{sec:cv}.
	\item[Web Browser] was selected as the control panel user interface. Using a browser for a UI is an easy way to achieve broad cross-platform compatibility and to enable remote access, both making the project more accessible and flexible.
	\item[Tornado] was selected as the web framework of choice in Python. Tornado is one of the most popular Python web frameworks. The Facebook team acquired it and made it open-source as a solution for high-speed communication and large traffic volumnes. After comparison with the Flask \footnotemark[11] web framework, Tornado was selected as it had a higher level of community activity and support, as well as more convenient extra libraries available (such as TornadoRPC).
	\item[Websockets] were chosen as the communication medium of choice. Websockets provide a high-speed, bi-directional communication channel between the client (browser) and server (BlocSim). Two major wrapper libraries exist for websockets currently, SockJS and Socket.io\footnotemark[12]. SockJS was selected after discovering a number of bugs in the Socket.io client \cite{socketioBugs}.
	\item[JSON] was selected as the standard communication and storage format across all BlocSim systems. JSON is convenient to work with in Python, as JSON objects can convert directly to Python dictionary structures and vice versa. JSON can act as a standard data format for the local configuration save file (keystore), for client-server communication, and for block diagram model publishing. This is especially convenient, as the web control panel will be written in Javascript.
	\item[TornadoRPC] is the solution to remote control of BlocSim via external software. Not only is it capable of handling JSON remote procedure calls, it's incredibly simple to use and integrates tightly with the Tornado webserver as a request handler.
	\item[Mosquitto,] a lightweight publish/subscribe broker, was selected as the method of publishing block diagrams models for external access. After a brief comparison with an alternative publish/subscribe system, Redis\footnotemark[13], Mosquitto was selected. Both systems are easy to interact with through a Python client, however Mosquitto is built for publishing contiguous messages while Redis acts as a keystore. There was no point in separating the data in the block diagram models into key-value pairs, as the values are all associated with the particular frame they came from. Most of all, I had already worked with Mosquitto before.
\end{description}


%\clearpage

% =====================================================================

\section{Open-Source Delivery}

The BlocSim source, release build, issue tracking and documentation are to be publicly hosted online at GitHub \cite{blocsim}\cite{github}. Having a centralised, publicly visible location for these services and material provides both exposure for the project and valuable support infrastructure for any future work on the project (by its original author or others) which may take place. 

Additionally, every effort has been made to select only free and open source libraries and dependencies, making the project more accessible to developers.

BlocSim is to be licensed under GPLv2 \cite{gplv2}, a permissive license which guarantees freedom to share and change the software, appropriate for encouraging and facilitating open source development.
\\


% =====================================================================

\chapter{Implementation}

Implementation of the BlocSim prototype followed the choices of technologies and libraries laid out in Section \ref{sec:techSelection}. The primary focus was on rapid development and maximising user-friendliness of the \gls{ui} design. The result is a monolithic Python program covering all functionality, with a web control panel powered and styled by JQuery\footnote{JQuery - \url{http://jquery.com} and \url{http://jqueryui.com}}.
\\

To start BlocSim, users simply navigate to the \texttt{demo} folder and execute \texttt{./blocsim.py}. The webserver and associated services will start automatically. BlocSim will connect to the first available webcam, load its stored configuration from a JSON file (\texttt{config/config.db}), and start processing webcam frames.
\\

\newpage

Users can access the control panel and view the video stream from any computer in the network: simply navigate to \texttt{http://<host address>:8080}.

\begin{figure}[ht!]
\centering
\includegraphics[width=50mm]{images/BlocsimLogo.png}
\caption{The BlocSim Logo \cite{blocsim}}
\label{im:blocsimlogo}
\end{figure}

\vspace{0.5 cm}

A high-resolution (1920x1080 pixels), consumer-affordable webcam (Logitech C920 HD\footnote{Logitech C920 HD Webcam - \url{http://www.logitech.com/en-au/product/hd-pro-webcam-c920}}) was acquired to ensure capture resolution was not the limiting factor in the computer vision component. The camera is approximately 1m from the board.

\begin{figure}[ht!]
\centering
\includegraphics[width=175mm]{images/photo2.jpg}
\caption{Camera and whiteboard demonstration setup}
\label{im:hardware1}
\end{figure}

\clearpage

A demonstration block diagram has been constructed on a magnetic whiteboard. Aside from a loop of four valid electrical-circuit-themed blocks, the board includes a number of test features:
\begin{itemize}
\item a connector line with no connections (right)
\item a circular red block (right)
\item a 'block within a block' (left of circle)
\item a 'loose' block component (no connections, top)
\item stray image features in the same colour as block diagram components, but invalid configuration ('Bloc Sim' title, center)
\end{itemize}

The 'V1' and 'R1' components are magnetic cards, while all other features on the whiteboard consist of whiteboard marker directly drawn onto the board. There is little practical difference between the two, as the magnetic cards have similar visual properties (white, reflective, rendered with whiteboard marker)

\begin{figure}[ht!]
\centering
\includegraphics[width=75mm]{images/photo3.jpg}
\includegraphics[width=85mm]{images/photo4.jpg}
\caption{Logitech C920HD 1080p Camera; close-up of block diagram on whiteboard}
\label{im:hardware2}
\end{figure}

\clearpage

\section{Features \& Usage}

The BlocSim web control panel can be seen in Figure \label{im:screenshot_cv1}. Three tabs (Webcam, Publish/Subscribe, RPC) are available (top). Basic controls are available on a sidebar to the left, including pausing the video feed, switching webcams, video feed quality and selectively enabling publish/susbscribe streaming. The sidebar also signals if a feature on the server is unavailable (green/orange/red lights).

In the webcam tab, a select menu (combo box) above the video feed allows the user to select one of 16 streams to view. These images are generated during each stage of analysis of the webcam sketch, enabling users to better appreciate how BlocSim works and, in the case of sketch capture failing, troubleshoot their capture configuration.
\\

\begin{figure}[ht!]
\centering
\includegraphics[width=175mm]{images/screenshot_cv1.png}
\caption{The BlocSim Web Control Panel \cite{blocsim}}
\label{im:screenshot_cv1}
\end{figure}

\newpage

Scrolling down, a calibration panel provides sliders which update the configuration of the computer vision processing in real time. This is primarily for developer debugging purposes, but also allows users to easily adjust settings if the lighting changes significantly, and crop the video feed to only show the block diagram on a whiteboard. A row of buttons provides additional functionality, allowing the user to load and save this configuration, or save the current block diagram model (including all 16 processed images) to a folder.
\\

At the bottom of the Webcam tab, the last JSON message received from the server is displayed, showing details such as the framerate, frame dimensions and frame filesize.
\\

\begin{figure}[ht!]
\centering
\includegraphics[width=170mm]{images/screenshot_calib2.png} %\\
%\vspace{0.1 cm}
\includegraphics[width=170mm]{images/screenshot_info2.png}
\caption{BlocSim Control Panel - calibration sliders and server message \cite{blocsim}}
\label{im:screenshot_calib}
\end{figure}

\newpage
The Publish/Subscribe tab shows the JSON model corresponding to the block diagram in the current frame. This model (minus the space formatting) is published to the Mosquitto broker on every frame.
\\

To subscribe to the model, open a command line window and run: \\ \texttt{mosquitto\_sub -t blocsim}

\begin{figure}[ht!]
\centering
\includegraphics[width=150mm]{images/screenshot_pubsub.png}
\caption{BlocSim Control Panel - Block Diagram model \cite{blocsim}}
\label{im:screenshot_pubsub}
\end{figure}

\newpage

The final tab, RPC, is simply a log of all remote procedure calls made to the server. In order to demonstrate this feature, some of the UI buttons are implemented as remote procedure calls. An example python JSON-RPC script is show on-screen; a full list of available procedures is available on GitHub.

\begin{figure}[ht!]
\centering
\includegraphics[width=150mm]{images/screenshot_rpc.png}
\caption{BlocSim Control Panel - Remote Procedure Call server status \cite{blocsim}}
\label{im:screenshot_rpc}
\end{figure}

%\clearpage

\newpage

\subsection{Computer Vision}

The following pages are an abridged walkthrough of the computer vision processes employed by BlocSim. Not all image frames are reviewed.

\begin{figure}[ht!]
\centering
\includegraphics[width=140mm]{images/frame1.jpg}
\caption{BlocSim output image (1) - cropped frame \cite{blocsim}}
\label{im:frame1}
\end{figure}

\newpage
Image 3: shows the cropped frame after applying threshold bounds for hue, saturation and brightness (value) in the HSV colour range \& removing noise

\begin{figure}[ht!]
\centering
\includegraphics[width=140mm]{images/frame3.jpg}
\caption{BlocSim output image (3) - red \cite{blocsim}}
\label{im:frame3}
\end{figure}

\newpage
Image 4: shows the set of rectangular red contours which classified as potential block markers. Note that the circle has been rejected for being non-rectangular. The small hidden red shape on the right was rejected as it is not a closed, hollow shape. The bounding regions of the blocks are minimum rectangles which follow their axis of rotation. 

Also note that the whiteboard is not directly facing the camera (it is out-of-plane). This small distortion effect does not impact the recognition of the block diagram model.

\begin{figure}[ht!]
\centering
\includegraphics[width=140mm]{images/frame4.jpg}
\caption{BlocSim output image (4) - red block \cite{blocsim}}
\label{im:frame4}
\end{figure}

\newpage
Image 8: A similar procedure to images 2..4 has been applied to Green colour regions already. Only solid, approximately round shapes inside a red rectangle from (4) are accepted.

The green dots identify the block types. Note the red block in the centre has been rejected, as its only green dot is not near the corner of the shape. The red contour surrounding the word 'Sim' is also being ignored, as it did not contain an identifying dot.

\begin{figure}[ht!]
\centering
\includegraphics[width=140mm]{images/frame8.jpg}
\caption{BlocSim output image (8) - block ID \cite{blocsim}}
\label{im:frame8}
\end{figure}

\newpage
Image 12: Thresholding has been applied to black regions of the image. The bounds on what is considered a 'black' region are very broad to account for reflections on the whiteboard. 

The black regions are candidates for connector lines. They are dilated (expanded), and any part of the dilated regions intersecting a red block is considered a node. Any connectors without nodes will be ignored later.

\begin{figure}[ht!]
\centering
\includegraphics[width=140mm]{images/frame12.jpg}
\caption{BlocSim output image (12) - connector lines (mask) \cite{blocsim}}
\label{im:frame12}
\end{figure}

\newpage
Image 13: Nodes have been marked on the image.

\begin{figure}[ht!]
\centering
\includegraphics[width=140mm]{images/frame13.jpg}
\caption{BlocSim output image (13) - connection nodes \cite{blocsim}}
\label{im:frame13}
\end{figure}

\newpage
Image 15: All information so far has been combined, and paths between nodes and blocks drawn. For each connector line candidate from (12), all nodes within its perimeter are joined together. 

The result is a set of 4 identified blocks joined by a circular path, with a 5th block disconnected (top).

\begin{figure}[ht!]
\centering
\includegraphics[width=140mm]{images/frame15.jpg}
\caption{BlocSim output image (15) - block diagram overlay \cite{blocsim}}
\label{im:frame15}
\end{figure}

\newpage
Image 16: This final image shows the block diagram model without the background image.

\begin{figure}[ht!]
\centering
\includegraphics[width=140mm]{images/frame16.jpg}
\caption{BlocSim output image (16) - block model \cite{blocsim}}
\label{im:frame16}
\end{figure}

\clearpage
\newpage

Finally, we have the JSON Block diagram model corresponding to the previous set of images. Only a sample of the blocks and nodes are shown for brevity. The model consists of a list of blocks and list of nodes, each of which is assigned an ID, position, and list of connecting components. Block markers also describe their shape/size and block type.

\begin{figure}[ht!]
	\fontsize{8pt}{8pt}
	\singlespacing
	\begin{mdframed}
		\verbinput{images/example.json}
	\end{mdframed}
	\caption{Sample of JSON Block Diagram Model output (not all blocks, nodes shown)}
	\label{tab:json}
\end{figure}

\clearpage




% =====================================================================

\section{Technical Architecture}

Figure \ref{im:BlocsimBD3} shows the overall architecture of the BlocSim prototype's implementation. Broadcast messages are sent over the websocket connection by both the client (browser) and server at 10Hz. On each message, the server updates the browser client with all relevant information related to the last-processed frame. The client browser sends the server the current state of all its UI elements, including computer vision configuration sliders.
\\

The server stores all configuration items in a json keystore. This keystore is updated every time a client's broadcast packet arrives. While this is an acceptable implementation for a single client, this model will have to be updated to support multiple clients.

\begin{figure}[ht!]
\centering
\includegraphics[width=170mm]{images/BlocsimBD3.jpg}
\caption{BlocSim's Architecture}
\label{im:BlocsimBD3}
\end{figure}

Initially, BlocSim was built to stream the webcam feed in an .MJPEG format. However, MJPEG connections proved difficult to manage, partially due to a bug in the Webkit implementation for some browsers where the only way to disconnect the .MJPEG stream from the server is to close the tab.
\\

Instead, each websocket connection has associated with it a currently streaming image ID. Within each broadcast message, this image is encoded into a base64 string (which increases the file size by x1.33). This image is assigned to the 'data' URI of a .jpg image by javascript upon arrival at the browser.
\\

This is an acceptable implementation for the low frame rates required watching a primarily static diagram.

\begin{figure}[ht!]
\centering
\includegraphics[width=170mm]{images/BlocsimBD4.jpg}
\caption{Process flow for video stream}
\label{im:BlocsimBD4}
\end{figure}

%\newpage
%\clearpage

\noindent The Python webserver's functionality is split into several threads, including:

\begin{description}
	\item[Main Thread] - Executes the Tornado webserver IO Loop. Includes handling websockets and Remote Procedure Calls
	\item[Publish Thread] - Executes the Mosquitto client IO Loop
	\item[Capture Thread] - Reads from the camera when signalled
	\item[Webcam Thread] - Handles webcam connection/disconnection and storing frames
	\item[Processing Thread] - Uses OpenCV to generate images and the block model
	\item[Timer Thread] - Limits the webcam capture frame rate
\end{description}

\noindent These threads communicate via a series of event signallers and shared resources, such as the keystore database and image processing output.

\vspace{1 cm}

\noindent For more information on BlocSim's implementation and usage, see the resources outlined in Appendix \ref{ch:appendix}.


% =====================================================================

\chapter{Project Evaluation}

\section{Completion}

The creation of the BlocSim prototype according to speicifications laid out in Chapter \ref{ch:spec} was generally completed successfully. The system is very user friendly, very accessible and is able to interpret simple block diagram models. Unfortunately, due to time constraints the demonstration adapter for converting the block model into a digital logic model was not completed. Additionally, further work is required to synchronise the UI between multiple control panels.

\begin{table}[ht!]
	\center
	\begin{tabular}{$p{65mm}^l^p{65mm}} %$
		\hline
		\rowstyle{\bfseries}
		Feature & Complete & Incomplete \\
		\hline
		Surface Capture & \gtick & \\
		Human interface (Control Panel) & \gtick & full UI synchronisation between multiple clients \\
		External control interface (RPC) & \gtick & \\
		Configurable (JSON Keystore) & \gtick & More \gls{cv} settings should be user configurable \\
		Real-time Computer Vision for \newline Block Diagram recognition & \gtick & \\
		Block Diagram Model output \newline (MQTT Publish/Subscribe) & \gtick & \\
		\ldots & & \\
		Digital Logic Adapter & & \rcross \\
		Minimalist Digital Logic Simulator & & \rcross \\
		\hline
	\end{tabular}
	\caption{Feature completion for BlocSim prototype}
	\label{tab:completion}
\end{table} 

\newpage
%\clearpage

\section{Performance}

\subsection{Speed \& Resource Usage}

\begin{description}
	\item[Network] - For a 1080p image cropped to approximately 50\% of its width and height, the jpeg frame size after base64 encoding is approximately 60KB. At a nominal frame rate of 5FPS, this gives 2.4mbps bandwidth for video, which is quite manageable on local networks. A blocsim server intended for remote access over the web should be constrained to a lower frame rate using the UI controls.
	\item[CPU] - This has not been extensively tested. On a MacBook Pro Retina with a 2.4GHz i5 processor, 8GB RAM, and integrated Intel graphics, the server ran at approximately 70\% CPU usage with one client attached (local). This is acceptable for personal use on a modern middle-range computer. 
	\item[Frame Rate] - At a full 1080p on the above system, BlocSim was able to maintain image processing at the speed-limited 5FPS.
\end{description}

\newpage

\subsection{Computer Vision Reliability}

\begin{figure}[ht!]
\centering
\includegraphics[width=125mm]{images/frame4glow.jpg}
\caption{BlocSim output image (4) - reflections on whiteboard can result in missed block components}
\label{im:frame4glow}
\end{figure}

Overall, the block design and computer vision techniques employed in the BlocSim prototype are adequate to demonstrate the planned functionality. Colour thresholding limits must be re-tuned if the lighting or marker colour changes dramatically or a camera with significantly different properties to the previous one is used. Reflections from light sources in the room are a persistent issue. These can either be diffused, washing out the colour of features and shifting their hue outside the target colour range, or they can be focused, masking any image features underneath (see figure \ref{im:frame4glow}).

This implementation is not sufficiently robust to rely upon outside of controlled demonstrations. It is recommended that any future work either move away from colour processing or print the block cards onto a non-reflective surface, using non-reflective ink or toner.

\section{Design Decisions Review}
\label{ch:review:design}

Overall, the technologies selected for the prototype in Section \label{sec:techSelection} have worked well together. The interchangeability of JSON and Python dictionaries made passing data between the server, client, Mosquitto broker, keystore etc. very convenient. OpenCV has been very easy to work with thanks to a strong open source community, with tutorials, examples or other assistance available for each task I undertook with it.

On the other hand, the decision to run a completely monolithic server possibly resulted in a less than convenient architecture for keeping the UIs of multiple remote control panels synchronised. In fact, this feature was not fully implemented. I discovered Meteor\footnote{Meteor - \url{https://www.meteor.com/}}, an open-source Javascript framework running on node.js, after the prototype was nearly complete and changing architectures was impractical. Meteor uses a centralised MongoDB\footnote{MongoDB - \url{http://www.mongodb.org/}} database to store the server state, and automatically updates all the clients when the database is written to. I could have used a Meteor server for the front-end (web control panel), a Python program for the back-end (image processing, publish/subscribe) and a MongoDB database as a synchronisation and data sharing layer between them.

\section{Future Improvement}

The current prototype is useful, but only a small first step towards bridging block diagram sketches and simulation software. The full timeline for future improvements is documented on the GitHub wiki pages and issue tracker; a sample of the suggested approach is presented below.

\begin{description}
	\item[BlocSim 1.0] - The next release of the current prototype. This release should focus on usability. Fix bugs identified so far. Make the codebase more friendly to potential collaborating developers by adding python docstrings, cleaning up messy code and making easy optimisations. Do a basic implementation of UI synchronisation between client browsers.
	\item[BlocSim 1.1] - This release should focus on computer vision improvements and completing all the features initially nominated for the prototype. Make the block diagram recognition more robust against changes to cameras and lighting conditions, possibly by autobalancing brightness and colour saturation in the image. Write an adapter to transform the published block model into input for a simple third-party logic simulator.
	\item[ ... ]
	\item[BlocSim 2.0] - This release should focus on a major rewrite of BlocSim, to discard undesirable features and implement preferred architectures and computer vision methods. Implement the alternate method for identifying block types, as identified in Section \ref{ch:back:borders} (binary encoding along the border). This will facilitate a wider set of block types, which is required for almost all practical engineering domains. Ensure the user is able to rotate these blocks in any direction and maintain correct identification. Finally, split the server architecture into two parts, as suggested in \ref{ch:review:design}. 
	\item[BlocSim 2.1] - This release should focus on extending BlocSim's capabilities to include Optical Character Recognition (\gls{ocr})
\end{description}

% =====================================================================

\chapter{Conclusion}

The creation of the BlocSim prototype according to speicifications laid out in Chapter \ref{ch:spec} was generally a success. Recognition of the whiteboard block diagrams runs in real time and performs well under controlled lighting conditions, however requires some initial manual tuning according to lighting conditions and camera. Control of the system and access to the block diagram model is convenient and user friendly through both \gls{gui} and external software, although the calibration controls should be expanded and synchronisation of controls between multiple web clients completed. The planned adapter for demonstrating conversion of generic block diagram models to digital logic gate models is yet to be implemented.
\\

Work on BlocSim so far has demonstrated that computer vision based primarily on the colour of whiteboard marker features is not as reliable as is desired. Even with a high resolution image, variations in actual marker colour, thin or lightly drawn features and strong reflections from background light sources can be significant, in some cases causing the algorithm to miss image features and build an incomplete block diagram model. This issue can be partially resolved in future work by encoding the block type in black-and-white frame marker fiducials, and pre-printing them onto non-reflective magnetic cards (see Section \ref{ch:back:borders}).
\\

Overall, the current prototype is a useful but small first step towards bridging the gap between block diagram sketches and simulation software. BlocSim will require extensive future work as an open source project before it can truly be a solution to this problem.

% =====================================================================

\begin{comment}

\end{comment}
